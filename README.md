# Design-Pattern-JAVA-TEXT-GAME

디자인 패턴은 아이디어, 특정한 구현이 아니다. 프로젝트에 항상 적용해야 하는 것은 아니지만, 추후 재사용, 호환, 유지 보수시 발생하는 문제 해결을 예방하기 위해 패턴을 만들어 둔것이다.

원칙 - SOLID (객체지향 설계 원칙)
SRP(Single Responsibility Principle) : 단일 책임 원칙
클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.

OCP(Open-Closed Principle) : 개방-폐쇄 원칙
확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

Liskov Substitution Principle : 리스코프 치환 원칙
자식이 부모의 자리에 항상 교체될 수 있어야 함.

ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

DIP(Dependency Inversion Principle) : 의존 역전 원칙
고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

# 목적
본 소프트웨어 ‘낚시왕 어드벤처’는 텍스트 기반의 입출력을 사용하는 텍스트 어드벤쳐(인터랙티브 픽션)게임입니다. 
통합적 문제 인식을 통해 단순한 코드 생성이 아닌 개발 프로세스와 프로젝트 관리를 중요시 했습니다.
주제에 디자인패턴을 입히고 프로세스 모델을 선정하여 문서화와 효율적인 프로젝트 관리, 변경이나 재사용을 염두에 둔 작업을 하는 것이 목표입니다.

# 분석 및 설계

## 유스케이스


<img width="610" alt="스크린샷 2021-04-09 오후 4 33 36" src="https://user-images.githubusercontent.com/48669085/114145856-db904d00-9951-11eb-921f-497af936307b.png">

### 스테이트 패턴 적용


스테이트 패턴은 객체가 특정 상태에 따라 행위를 달리하는 상황에서, 상태를 객체화 하여 상태가 행동을 할 수 있도록 위임하는 패턴이다. <br>본 프로젝트에서는 날씨 상태를 객체화 하여 날씨 상태에서 행동을 가능케 한다.


**문제점**


프로그램 내부적으로 낚시하기 행동을 시행할 때 마다 날씨 변화가 필요하다.

날씨 변화는 현실 세계의 변덕스러운 날씨를 반영하기 위하여 날씨가 밝아지면 화창한 날이 되고 화창한 날에서 흐려지면 선선한 날이 되는 것과 같이 동일하게 구현하기 위하여 스테이트 패턴을 사용하게 되었다.


**해결 방안**


스테이트 패턴을 사용하여 날씨 특정 상태가 행동을 할 수 있도록 구현한다 날씨가 좋아지는 함수와 날씨가 악화되는 함수 shining(), cool(), clouding() 를 구현하여 특정 상태가 변할 수 있도록 한다. 상태가 변화할 때 원하는 상태로 변하기 위하여 State 인터페이스를 상속받는 클래스 CoolDay , RainyDay, SunnyDay 즉 날씨 상태 클래스에서 알맞게 구현한다.


<img width="530" alt="스크린샷 2021-04-09 오후 4 33 42" src="https://user-images.githubusercontent.com/48669085/114145862-df23d400-9951-11eb-84b7-a109508a68a2.png">

## 유스케이스


<img width="610" alt="스크린샷 2021-04-09 오후 4 33 51" src="https://user-images.githubusercontent.com/48669085/114145868-e0550100-9951-11eb-916f-28ace3a47aa5.png">


### 스트레티지 패턴 적용


스트래티지 패턴은 같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화 되어 있고 이 알고리즘들을 런타임시에 선택할 수 있게 해준다. 행동을 상속받는 대신 올바른 행동 객체로 구성됨으로써 행동을 부여 받고, 다시 컴파일 하지 않아도 객체의 행동을 바꿀수 있다.


**문제점**


2.2절의 유스케이스 ‘미끼’를 적용한 패턴이다. 낚시대에 미끼를 거는 기능을 구현하는 과정에서 걸 수 있는 미끼가 달라져서 각각 올라가는 낚시 능력이 달라질 때마다 계속 상속으로 구현 하면, 프로그램을 확장할 필요가 생길 때 모든 상속 클래스들 내 기존 코드의 내용을 수정하거나 하는 문제가 생긴다.


**해결 방안**


변경되는 부분을 분리하여 인터페이스로 구현한다. 미끼를 사용하는 기능은 낚시 능력이 높아지고 돈을 차감한다는 큰 부분은 같지만 각각의 미끼마다 올라가는 낚시 능력과 가격은 다르다. 따라서 FishingStrategy인터페이스를  EarthwormStrategy와 ShrimpStrategy, SquidStrategy가 각각 구현한다.

<img width="539" alt="스크린샷 2021-04-09 오후 4 33 59" src="https://user-images.githubusercontent.com/48669085/114145877-e0ed9780-9951-11eb-8431-b9f6abcc1e46.png">


## 유스케이스

<img width="602" alt="스크린샷 2021-04-09 오후 4 34 08" src="https://user-images.githubusercontent.com/48669085/114145881-e1862e00-9951-11eb-8881-76c2628fe9a8.png">


### 데코레이터 패턴 적용


데코레이터 패턴에서는 객체에 추가적인 요건을 동적으로 첨가합니다. 데코레이터는 서브 클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공합니다.

**문제점**


상속을 써서 도구에 버프를 거는데 필요한 금액과 버프 되는 낚시 능력치를 계산하는 방법은 변경사항이 생길 경우 코드를 직접 수정하는 문제가 생길 수 있다. 또한 버프를 하나만 거는 것이 아니라 2개 이상 조합하여 걸고 싶을 때 각 조합별로 하위클래스를 구현해야 하는 문제점도 생긴다.


**해결 방안**


도구를 향상하는 과정에서 상속을 사용할 수 있습니다.
하지만 도구를 향상하는 과정에서 변경사항이 생길 경우 코드를 직접 수정하는 문제가 생길 수 있습니다. 또한 버프를 하나만 거는 것이 아니라 2개 이상 조합하여 걸고 싶을 때 각 조합별로 하위클래스를 구현해야 하는 문제점도 생깁니다.



<img width="503" alt="스크린샷 2021-04-09 오후 4 34 13" src="https://user-images.githubusercontent.com/48669085/114145885-e2b75b00-9951-11eb-87ba-e39386307f27.png">


## 유스케이스


<img width="611" alt="스크린샷 2021-04-09 오후 4 34 21" src="https://user-images.githubusercontent.com/48669085/114145889-e2b75b00-9951-11eb-80c6-8f56c5b0da2b.png">


### 팩토리메서드 패턴 적용


팩토리 메소드 패턴은 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들어지는 서브 클래스에서 결정하게 만든다. 
팩토리 메소드 패턴에서 사용하는 팩토리 메소드는 객체 생성을 처리하며, 객체를 생성하는 작업을 서브 클래스에 캡슐화 시킬수 있다. 이렇게 하면 수퍼 클래스에 있는 클라이언트 코드와 서브클래스에 있는 객체 생성 코드를 분리시킬 수 있다.


**문제점**

사용자가 낚시하기를 선택하면 강에서 낚시할지 바다에서 낚시할지 호수에서 낚시할지를 정해야 한다. 그리고 각각의 낚시터에서 잡히는 물고기 종류와 특징이 달라야 한다.
하지만 낚시터에 낚시대를 던져서 물고기를 잡는 일련의 행동은 변하지 않는다.
팩토리 메소드 패턴을 이용해 물고기 객체를 생성하기 위한 인터페이스를 정의하고, 어떤 클래스의 인스턴스를 만들지는 하위 클래스인 bass, goldfish등이 결정하게 한다.


**해결 방안**


물고기를 생성해 잡을수 있게 해주는 catchFish() 팩토리 메소드와 Fishing()메소드를 결합해 하나의 프레임워크로 만든다. 물고기가 생성되는 낚시터 클래스와 물고기 클래스를 추상클래스로 만들고 그 클래스들을 확장하는 구상 클래스들을 만든다. 각각의 낚시터 클래스들에서는 그 낚시터에서 잡히는 물고기들을 생성하는데 관한 것들이 캡슐화 되어 있다.

<img width="457" alt="스크린샷 2021-04-09 오후 4 34 33" src="https://user-images.githubusercontent.com/48669085/114145891-e34ff180-9951-11eb-9d52-316b5132a95b.png">



<img width="602" alt="스크린샷 2021-04-09 오후 4 34 40" src="https://user-images.githubusercontent.com/48669085/114145894-e34ff180-9951-11eb-88c1-400cc46e493e.png">


### 템플릿메소드 패턴 적용


템플릿 메소드 패턴에서는 알고리즘의 골격을 정의한다. 알고리즘의 여러 단계 중 일부는 서브클래스에서 구현할 수 있다. 템플릿 메소드를 이용하면 알고리즘의 구조는 그대로 유지하면서 서브클래스에서 특정 단계를 재정의할 수 있다.

**문제점**


생선 요리는 기본적으로 생선을 가지고 하는 요리이기 때문에 요리 과정이 비슷하다. 따라서 생선조림 레시피, 생선구이 레시피, 스시를 만드는 레시피 클래스를 각각 만들면 코드가 중복된다.


**해결 방안**


공통적인 부분을 추상화시켜서 베이스 클래스를 만들고, 각 레시피가 조금씩 다르게 만뜨는 단계의 알고리즘을 추상 메소드로 선언한다.
템플릿 메소드 패턴을 적용하면 템플릿 메소드인 prepareRecipe()에서 요리과정 알고리즘의 골격을 정의하고, 바뀌는 특정 단계만 서브 클래스 BraisedFish, GrilledFish, Sushi에서 구현한다.

<img width="392" alt="스크린샷 2021-04-09 오후 4 34 46" src="https://user-images.githubusercontent.com/48669085/114145895-e3e88800-9951-11eb-922d-6383052c9fd5.png">




# 결과

# 회고

|패턴|완성도|미완성 부분|
|--------|--------|--------|
|Strategy 패턴|90%|생성할 수 있는 캐릭터가 Man하나였는데,  FishMan구상 클래스를 상속받는 서브클래스들을 조금 다양하게 생성해 기본 능력치나 특징이 다른 캐릭터를 만들었으면 더 좋았을 것 같다. |
|Factory 패턴|90%|낚시 게임인데도 불구하고 생성할 수 있는 물고기를 6마리 밖에 못 만들었다.|
|State 패턴|80%|스테이트 패턴을 구현하면서 내부 객체 상태가 직접 행동함으로써 내부적으로 출력값변경은 이루어졌지만 인스턴스 변수가 없기에 변수는 변경되지 않았다.|
|Decorator 패턴|80%|좀더 버프를 다양하게 만들고, 특별한 능력이 부여되는 버프 기능을 넣지 못한 점이 아쉽다. 또 버프를 여러 가지로 조합해서 걸면 새로운 능력이 주어지거나 하여 데코레이터를 다양하게 사용하게 만들지 못한 점도 아쉽다.|
|Template Method 패턴|80%|요리 레시피를 많이 알지 못해서 순서를 조금 억지스럽게 만든게 있는 것 같다.|




 

